name: Cleanup Releases

on:
  workflow_dispatch:
    inputs:
      mode:
        description: "Action: 'mark' sets releases to prerelease, 'delete' removes them"
        required: true
        default: mark
        type: choice
        options:
          - mark
          - delete
      keepLatest:
      
        description: "How many latest releases to keep unchanged"
        required: true
        default: '1'
      filter:
        description: "Optional filter (substring) for tag names"
        required: false
      deleteTags:
        description: "When deleting, also remove the corresponding Git tags (only for mode=delete)"
        required: true
        default: 'false'

permissions:
  contents: write

jobs:
  cleanup:
    runs-on: ubuntu-latest
    steps:
      - name: Cleanup releases via GitHub API
        uses: actions/github-script@v7
        with:
          script: |
            const mode = core.getInput('mode') || 'mark';
            const keepLatest = parseInt(core.getInput('keepLatest') || '1', 10);
            const filter = core.getInput('filter') || '';
            const deleteTags = (core.getInput('deleteTags') || 'false').toLowerCase() === 'true';

            const all = await github.paginate(github.rest.repos.listReleases, {
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100,
            });

            let releases = all;
            if (filter) {
              releases = releases.filter(r => (r.tag_name || '').includes(filter));
            }

            releases.sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const target = releases.slice(keepLatest);

            core.info(`Found ${all.length} releases, filtered=${releases.length}, operating on ${target.length}. mode=${mode}`);

            for (const r of target) {
              if (mode === 'mark') {
                if (!r.prerelease) {
                  await github.rest.repos.updateRelease({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    release_id: r.id,
                    prerelease: true,
                  });
                  core.info(`Marked ${r.tag_name} as prerelease.`);
                } else {
                  core.info(`Skip ${r.tag_name} (already prerelease).`);
                }
              } else if (mode === 'delete') {
                await github.rest.repos.deleteRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: r.id,
                });
                core.info(`Deleted release ${r.tag_name}.`);
                if (deleteTags && r.tag_name) {
                  try {
                    await github.rest.git.deleteRef({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      ref: `tags/${r.tag_name}`,
                    });
                    core.info(`Deleted tag ${r.tag_name}.`);
                  } catch (err) {
                    core.warning(`Failed to delete tag ${r.tag_name}: ${err.message}`);
                  }
                }
              }
            }